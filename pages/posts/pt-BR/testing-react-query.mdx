---
title: Testando o React Query
publishedOn: Sex. 15 de jul. 2022
tags: [React, Tests, React Query]
author: TkDodo
---

Esse post faz parte do [TkDodo's blog](https://tkdodo.eu/blog/) e √© uma tradu√ß√£o para o Portugu√™s.

Perguntas sobre o t√≥pico de teste surgem com bastante frequ√™ncia junto com o React Query, ent√£o tentarei responder algumas delas aqui. 
Acho que uma raz√£o para isso √© que testar componentes "inteligentes" (tamb√©m chamados de [componentes de cont√™iner](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) ) 
n√£o √© a coisa mais f√°cil de fazer. Com o surgimento dos hooks, essa divis√£o foi amplamente preterida. Agora √© encorajado a consumir hooks 
diretamente onde voc√™ precisa deles, em vez de fazer uma divis√£o arbitr√°ria e detalhar os adere√ßos.

Eu acho que isso geralmente √© uma melhoria muito boa para colocation e legibilidade de c√≥digo, mas agora temos mais componentes que consomem depend√™ncias 
fora de "apenas props".

Eles podem ser useContext. Eles podem ser useSelector. Ou eles podem ser useQuery.

Esses componentes tecnicamente n√£o s√£o mais puros, porque cham√°-los em ambientes diferentes leva a resultados diferentes. Ao test√°-los, voc√™ precisa 
configurar cuidadosamente os ambientes ao redor para que as coisas funcionem.

## Simulando solicita√ß√µes de rede

Como o React Query √© uma biblioteca de gerenciamento de estado de servidor ass√≠ncrono, seus componentes provavelmente far√£o solicita√ß√µes para um back-end. 
Ao testar, esse back-end n√£o est√° dispon√≠vel para entregar dados de fato e, mesmo assim, voc√™ provavelmente n√£o deseja tornar seus testes dependentes disso.

Existem muitos artigos por a√≠ sobre como mock de dados com jest. Voc√™ pode simular seu cliente de API, se tiver um. Voc√™ pode simular busca ou axios 
diretamente. S√≥ posso apoiar o que Kent C. Dodds escreveu em seu artigo [Stop mocking fetch](https://kentcdodds.com/blog/stop-mocking-fetch):

Use o service worker simulado por @ApiMocking

- funciona no n√≥ para teste
- suporta REST e GraphQL
- tem um [story book addon](https://storybook.js.org/addons/msw-storybook-addon/) para que voc√™ possa escrever hist√≥rias para seus componentes que useQuery
- funciona no navegador para fins de desenvolvimento, e voc√™ ainda ver√° as solicita√ß√µes saindo nas ferramentas de desenvolvimento do navegador
- trabalha com cypress, semelhante a fixtures

Com nossa camada de rede sendo cuidada, podemos come√ßar a falar sobre coisas espec√≠ficas do React Query para ficar de olho:

## QueryClientProvider

Sempre que voc√™ usa React Query, voc√™ precisa de um QueryClientProvider e d√° a ele um queryClient - um recipiente que cont√©m o QueryCache . O cache, 
por sua vez, manter√° os dados de suas consultas.

Eu prefiro dar a cada teste seu pr√≥prio QueryClientProvider e criar um novo QueryClient para cada teste. Dessa forma, os testes s√£o completamente isolados
uns dos outros. Uma abordagem diferente pode ser limpar o cache ap√≥s cada teste, mas gosto de manter o estado compartilhado entre os testes o m√≠nimo 
poss√≠vel. Caso contr√°rio, voc√™ poder√° obter resultados inesperados e irregulares se executar seus testes em paralelo.

## Para hooks personalizado

```Javascript
const createWrapper = () => {
  // ‚úÖ creates a new QueryClient for each test
  const queryClient = new QueryClient()
  return ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

test("my first test", async () => {
  const { result } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })
}
```

## Para componentes

Se voc√™ quiser testar um Component que usa um gancho useQuery , voc√™ tamb√©m precisa encapsular esse Component em QueryClientProvider. 
Um pequeno wrapper em torno da renderiza√ß√£o da react-testing-library parece ser uma boa escolha. D√™ uma olhada em como o React Query faz isso 
internamente para seus testes.

## Desativar novas tentativas

√â uma das "pegadinhas" mais comuns com React Query e testes: a biblioteca tem como padr√£o tr√™s novas tentativas com backoff exponencial, o que significa
que seus testes provavelmente atingir√£o o tempo limite se voc√™ quiser testar uma consulta err√¥nea. A maneira mais f√°cil de desativar as novas tentativas
√©, novamente, por meio do QueryClientProvider . Vamos estender o exemplo acima:

```Javascript
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        // ‚úÖ turns retries off
        retry: false,
      },
    },
  })

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

test("my first test", async () => {
  const { result } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })
}
```

Isso definir√° os padr√µes para todas as consultas na √°rvore de componentes como "sem novas tentativas". √â importante saber que isso s√≥ funcionar√° se seu 
useQuery real n√£o tiver tentativas expl√≠citas definidas. Se voc√™ tiver uma consulta que deseja 5 tentativas, isso ainda ter√° preced√™ncia, porque os 
padr√µes s√£o usados ‚Äã‚Äãapenas como um fallback.

## setQueryDefaults

O melhor conselho que posso dar para esse problema √©: N√£o defina essas op√ß√µes em useQuery diretamente. Tente usar e substituir os padr√µes o m√°ximo poss√≠vel e, se voc√™ realmente precisar alterar algo para consultas espec√≠ficas, use queryClient.setQueryDefaults .

Ent√£o, por exemplo, em vez de definir retry em useQuery:

```javascript
const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  // üö® you cannot override this setting for tests!
  const queryInfo = useQuery('todos', fetchTodos, { retry: 5 })
}
```

Defina assim:

```javascript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
    },
  },
})

// ‚úÖ only todos will retry 5 times
queryClient.setQueryDefaults('todos', { retry: 5 })

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
```

Aqui, todas as consultas v√£o tentar novamente duas vezes, apenas todos v√£o repetir cinco vezes, e ainda tenho a op√ß√£o de desativ√°-lo para todas as 
consultas nos meus testes üôå.

## ReactQueryConfigProvider


```javascript
c√≥pia deReactQueryConfigProvider: copie o c√≥digo para a √°rea de transfer√™ncia
const ReactQueryConfigProvider = ({ children, defaultOptions }) => {
  const client = useQueryClient()
  const [newClient] = React.useState(
    () =>
      new QueryClient({
        queryCache: client.getQueryCache(),
        muationCache: client.getMutationCache(),
        defaultOptions,
      })
  )

  return (
    <QueryClientProvider client={newClient}>{children}</QueryClientProvider>
  )
}
```

Voc√™ pode ver isso em a√ß√£o neste [exemplo](https://codesandbox.io/s/react-query-config-provider-v3-lt00f) no codesandbox.

## Sempre aguarde a consulta

``` javascript
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  })
  return ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

test("my first test", async () => {
  const { result, waitFor } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })

  // ‚úÖ wait until the query has transitioned to success state
  await waitFor(() => result.current.isSuccess)

  expect(result.current.data).toBeDefined()
}
```

Atualiza√ß√£o :

@testing-library/react v13.1.0 tamb√©m tem um novo renderHook que voc√™ pode usar. No entanto, ele n√£o retorna seu pr√≥prio waitFor util, 
ent√£o voc√™ ter√° que usar o que voc√™ pode importar de @testing-library/react. A API √© um pouco diferente, pois n√£o permite retornar um boolean, 
mas espera um Promise. Isso significa que devemos adaptar nosso c√≥digo um pouco:

```javascript
import { waitFor, renderHook } from '@testing-library/react'

test("my first test", async () => {
  const { result } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })

  // ‚úÖ return a Promise via expect to waitFor
  await waitFor(() => expect(result.current.isSuccess).toBe(true))

  expect(result.current.data).toBeDefined()
}
```

## Silenciar o console de erro

Por padr√£o, o React Query imprime erros no console. Eu acho que isso √© bastante perturbador durante os testes, porque voc√™ ver√° üî¥ no console mesmo que 
todos os testes sejam üü¢. O React Query permite sobrescrever esse comportamento padr√£o [definindo um logger](https://react-query.tanstack.com/reference/setLogger), 
ent√£o √© isso que costumo fazer:

```javascript
import { setLogger } from 'react-query'

setLogger({
  log: console.log,
  warn: console.warn,
  // ‚úÖ no more errors on the console
  error: () => {},
})
```

Atualizar

setLogger foi removido na v4. Em vez disso, voc√™ pode passar seu logger personalizado como prop para o QueryClient que voc√™ cria:

```javascript
c√≥pia delogger-prop: copie o c√≥digo para a √°rea de transfer√™ncia
const queryClient = new QueryClient({
  logger: {
    log: console.log,
    warn: console.warn,
    // ‚úÖ no more errors on the console
    error: () => {},
  }
})
```

Al√©m disso, os erros n√£o s√£o mais registrados no modo de produ√ß√£o para evitar confus√£o.

## Juntando tudo

Eu configurei um reposit√≥rio r√°pido onde tudo isso vem bem junto: mock-service-worker, react-testing-library e o wrapper mencionado. 
Ele cont√©m quatro testes - testes b√°sicos de falha e sucesso para ganchos e componentes personalizados. D√™ uma olhada 
aqui: https://github.com/TkDodo/testing-react-query



