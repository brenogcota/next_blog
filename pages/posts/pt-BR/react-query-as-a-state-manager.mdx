---
title: React Query como um gerenciador de estado
publishedOn: Sex. 15 de jul. 2022
tags: [React, Javascript, React Query]
author: TkDodo
---

Esse post faz parte do [TkDodo's blog](https://tkdodo.eu/blog/) e √© uma tradu√ß√£o para o Portugu√™s.

O React Query √© amado por muitos por simplificar drasticamente a busca de dados em aplicativos React. Portanto, pode ser uma surpresa se eu lhe disser que o React Query na verdade N√ÉO √© uma biblioteca de busca de dados.

Ele n√£o busca nenhum dado para voc√™ e apenas um conjunto muito pequeno de recursos est√° diretamente vinculado √† rede (como o OnlineManager , refetchOnReconnect ou retrying offlinemutation ). Isso tamb√©m se torna aparente quando voc√™ escreve sua primeira queryFn e precisa usar algo para realmente obter os dados, como fetch , axios , ky ou at√© graphql-request .

Ent√£o, se o React Query n√£o √© uma biblioteca de busca de dados, o que √©?

## Um gerenciador de estado ass√≠ncrono

React Query √© um gerenciador de estado ass√≠ncrono. Ele pode gerenciar qualquer forma de estado ass√≠ncrono - fica feliz desde que receba uma Promise. Sim, 
na maioria das vezes, produzimos Promises por meio de busca de dados, ent√£o √© a√≠ que brilha. Mas ele faz mais do que apenas lidar com estados de 
carregamento e erro para voc√™. √â um "gerente de estado global" adequado, real. O QueryKey identifica exclusivamente sua consulta, portanto, desde que voc√™ 
chame a consulta com a mesma chave em dois locais diferentes, eles obter√£o os mesmos dados. Isso pode ser melhor abstra√≠do com um gancho personalizado para
que n√£o tenhamos que acessar a fun√ß√£o de busca de dados real duas vezes:

```javascript
export const useTodos = () => useQuery(['todos'], fetchTodos)

function ComponentOne() {
  const { data } = useTodos()
}

function ComponentTwo() {
  // ‚úÖ will get exactly the same data as ComponentOne
  const { data } = useTodos()
}

const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ComponentOne />
      <ComponentTwo />
    </QueryClientProvider>
  )
}
```

Esses componentes podem estar em qualquer lugar em sua √°rvore de componentes. Desde que estejam sob o mesmo QueryClientProvider , eles obter√£o os mesmos 
dados. O React Query tamb√©m desduplicar√° solicita√ß√µes que ocorreriam ao mesmo tempo, portanto, no cen√°rio acima, mesmo que dois componentes solicitem os 
mesmos dados, haver√° apenas uma solicita√ß√£o de rede.

## Uma ferramenta de sincroniza√ß√£o de dados

Como o React Query gerencia o estado ass√≠ncrono (ou, em termos de busca de dados: estado do servidor), ele assume que o aplicativo front-end n√£o "possui" os dados. E isso est√° totalmente certo. Se exibirmos dados na tela que buscamos de uma API, exibiremos apenas um "instant√¢neo" desses dados - a vers√£o de como eles eram quando os recuperamos. Ent√£o a pergunta que temos que nos fazer √©:

Esses dados ainda s√£o precisos depois de busc√°-los?

A resposta depende totalmente do dom√≠nio do nosso problema. Se buscarmos uma postagem no Twitter com todas as curtidas e coment√°rios, provavelmente ela ficar√° desatualizada (obsoleta) rapidamente. Se buscarmos taxas de c√¢mbio atualizadas diariamente, bem, nossos dados ser√£o bastante precisos por algum tempo, mesmo sem rebuscar.

O React Query fornece os meios para sincronizar nossa vis√£o com o propriet√°rio real dos dados - o backend. E, ao fazer isso, erra por atualizar com frequ√™ncia, em vez de n√£o atualizar com frequ√™ncia suficiente.

## Antes do React Query

Duas abordagens para a busca de dados eram bastante comuns antes de bibliotecas como React Query virem em socorro:

- buscar uma vez, distribuir globalmente, raramente atualizar
  Isso √© praticamente o que eu tenho feito muito com redux. Em algum lugar, despacho uma a√ß√£o que inicia a busca de dados, geralmente na montagem do aplicativo. Depois de obter os dados, n√≥s os colocamos em um gerenciador de estado global para que possamos acess√°-los em qualquer lugar em nosso aplicativo. Afinal, muitos componentes precisam de acesso √† nossa lista de tarefas. Rebuscamos esses dados? N√£o, n√≥s o "baixamos", ent√£o j√° o temos, por que dever√≠amos? Talvez se dispararmos uma solicita√ß√£o POST para o back-end, ele ser√° gentil o suficiente para nos devolver o estado "mais recente". Se voc√™ quiser algo mais preciso, voc√™ sempre pode recarregar a janela do navegador...

- buscar em cada montagem, mant√™-lo local
  √Äs vezes, tamb√©m podemos pensar que colocar dados no estado global √© "demais". N√≥s s√≥ precisamos dele neste Di√°logo Modal, ent√£o por que n√£o busc√°-lo bem na hora em que o Di√°logo √© aberto. Voc√™ sabe o que fazer: useEffect , array de depend√™ncia vazio (jogue um eslint-disable nele se ele gritar), setLoading(true) e assim por diante ... os dados. O que mais podemos fazer, o estado local se foi...


Ambas as abordagens s√£o bastante sub-√≥timas. O primeiro n√£o atualiza nosso cache local com frequ√™ncia suficiente, enquanto o segundo potencialmente busca novamente com muita frequ√™ncia e tamb√©m tem um ux question√°vel porque os dados n√£o est√£o l√° quando buscamos pela segunda vez.

Ent√£o, como o React Query aborda esses problemas?

## Stale While Revalidate

Voc√™ j√° deve ter ouvido isso antes, √© o mecanismo de cache que o React Query usa. N√£o √© nada novo - voc√™ pode ler sobre as extens√µes de controle de cache HTTP para conte√∫do obsoleto aqui . Em resumo, isso significa que o React Query armazenar√° dados em cache para voc√™ e os fornecer√° quando voc√™ precisar, mesmo que esses dados n√£o estejam mais atualizados (obsoletos). O princ√≠pio √© que dados obsoletos s√£o melhores do que nenhum dado, porque nenhum dado geralmente significa um spinner de carregamento, e isso ser√° percebido como "lento" pelos usu√°rios. Ao mesmo tempo, ele tentar√° realizar uma nova busca em segundo plano para revalidar esses dados.

## Buscas inteligentes

A invalida√ß√£o de cache √© muito dif√≠cil, ent√£o quando voc√™ decide que √© hora de solicitar novos dados ao back-end? Certamente n√£o podemos fazer isso toda vez que um componente que chama useQuery √© renderizado novamente. Isso seria insanamente caro, mesmo para os padr√µes modernos.

Portanto, o React Query est√° sendo inteligente e escolhe pontos estrat√©gicos para acionar um refetch. Pontos que parecem ser um bom indicador para dizer: "Sim, agora seria um bom momento para obter alguns dados". Estes s√£o:

- refetchOnMount
  Sempre que um novo componente que chama useQuery √© montado, o React Query far√° uma revalida√ß√£o.

- refetchOnWindowFocus
  Sempre que voc√™ focar na guia do navegador, haver√° uma nova busca. Este √© o meu momento favorito para fazer uma revalida√ß√£o, mas muitas vezes √© mal interpretado. Durante o desenvolvimento, mudamos de guia do navegador com muita frequ√™ncia, ent√£o podemos perceber isso como "demais". Em produ√ß√£o, no entanto, provavelmente indica que um usu√°rio que deixou nosso aplicativo aberto em uma guia agora volta de verificar e-mails ou ler o twitter. Mostrar a eles as atualiza√ß√µes mais recentes faz todo o sentido nessa situa√ß√£o.

- refetchOnReconnect
  Se voc√™ perder sua conex√£o de rede e recuper√°-la, tamb√©m √© um bom indicador para revalidar o que voc√™ v√™ na tela.
  
Por fim, se voc√™, como desenvolvedor do seu aplicativo, souber um bom momento, poder√° invocar uma invalida√ß√£o manual por meio de queryClient.invalidateQueries . Isso √© muito √∫til depois que voc√™ executa uma muta√ß√£o.

## Deixando o React Query fazer sua m√°gica

Eu amo esses padr√µes , mas como eu disse antes, eles s√£o voltados para manter as coisas atualizadas, n√£o para minimizar a quantidade de solicita√ß√µes de rede. Isso ocorre principalmente porque o padr√£o staleTime √© zero , o que significa que toda vez que voc√™, por exemplo, monta uma nova inst√¢ncia de componente, voc√™ obter√° uma nova busca em segundo plano. Se voc√™ fizer muito isso, especialmente com montagens em curta sucess√£o que n√£o est√£o no mesmo ciclo de renderiza√ß√£o, poder√° ver muitas buscas na guia de rede. Isso porque o React Query n√£o pode desduplicar em tais situa√ß√µes:

```javascript
function ComponentOne() {
  const { data } = useTodos()

  if (data) {
    // ‚ö†Ô∏è mounts conditionally, only after we already have data
    return <ComponentTwo />
  }
  return <Loading />
}

function ComponentTwo() {
  // ‚ö†Ô∏è will thus trigger a second network request
  const { data } = useTodos()
}

const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ComponentOne />
    </QueryClientProvider>
  )
}
```

> O que est√° acontecendo aqui, acabei de buscar meus dados 2 segundos atr√°s, por que outra solicita√ß√£o de rede est√° acontecendo? Isso √© uma loucura!

  ‚Äî Rea√ß√£o leg√≠tima ao usar React Query pela primeira vez
  

Nesse ponto, pode parecer uma boa ideia passar os dados via props ou coloc√°-los no React Context para evitar a perfura√ß√£o de props, ou apenas desligar os sinalizadores refetchOnMount / refetchOnWindowFocus porque toda essa busca √© demais !

Geralmente, n√£o h√° nada de errado em passar dados como adere√ßos. √â a coisa mais expl√≠cita que voc√™ pode fazer e funcionaria bem no exemplo acima. Mas e se ajustarmos um pouco o exemplo para uma situa√ß√£o mais real:

```javascript
function ComponentOne() {
  const { data } = useTodos()
  const [showMore, toggleShowMore] = React.useReducer(
    (value) => !value,
    false
  )

  // yes, I leave out error handling, this is "just" an example
  if (!data) {
    return <Loading />
  }

  return (
    <div>
      Todo count: {data.length}
      <button onClick={toggleShowMore}>Show More</button>
      // ‚úÖ show ComponentTwo after the button has been clicked
      {showMore ? <ComponentTwo /> : null}
    </div>
  )
}
```


Neste exemplo, nosso segundo componente (que tamb√©m depende dos dados de tarefas) s√≥ ser√° montado depois que o usu√°rio clicar em um bot√£o. Agora imagine que nosso usu√°rio clique nesse bot√£o depois de alguns minutos. Uma nova busca em segundo plano n√£o seria legal nessa situa√ß√£o, para que possamos ver os valores atualizados de nossa lista de tarefas?

Isso n√£o seria poss√≠vel se voc√™ escolhesse qualquer uma das abordagens acima mencionadas que basicamente ignoram o que o React Query deseja fazer.

Ent√£o, como podemos ter nosso bolo e com√™-lo tamb√©m?

## Personalizar staleTime

Talvez voc√™ j√° tenha adivinhado a dire√ß√£o em que quero ir: A solu√ß√£o seria definir staleTime para um valor com o qual voc√™ se sinta confort√°vel para seu caso de uso espec√≠fico. A principal coisa a saber √©:

![image](https://user-images.githubusercontent.com/106157862/179303091-2734e6f1-6d8c-4545-9c66-f30f9e9c2ff1.png)


Tamb√©m n√£o h√° valor "correto" para staleTime . Em muitas situa√ß√µes, os padr√µes funcionam muito bem. Pessoalmente, gosto de definir um m√≠nimo de 20 segundos para desduplicar solicita√ß√µes nesse per√≠odo de tempo, mas depende totalmente de voc√™.

## B√¥nus: usando setQueryDefaults

Desde a v3, o React Query suporta uma √≥tima maneira de definir valores padr√£o por Query Key via QueryClient.setQueryDefaults . Portanto, se voc√™ seguir os padr√µes descritos em #8: Effective React Query Keys , voc√™ pode definir padr√µes para qualquer granularidade que desejar, porque passar Query Keys para setQueryDefaults segue a correspond√™ncia parcial padr√£o que, por exemplo, Query Filters tamb√©m possui:

```javascript
c√≥pia desetQueryDefaults: copie o c√≥digo para a √°rea de transfer√™ncia
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // ‚úÖ globally default to 20 seconds
      staleTime: 1000 * 20,
    },
  },
})

// üöÄ everything todo-related will have a 1 minute staleTime
queryClient.setQueryDefaults(todoKeys.all, { staleTime: 1000 * 60 })
```

## Uma nota sobre a separa√ß√£o de interesses

√â uma preocupa√ß√£o aparentemente leg√≠tima que adicionar ganchos como useQuery a componentes de todas as camadas em seu aplicativo misture as responsabilidades do que um componente deve fazer. Nos velhos tempos , o padr√£o de componente "smart-vs-dumb", "container-vs-presentational" era onipresente. Ele prometia separa√ß√£o clara, desacoplamento, reutiliza√ß√£o e facilidade de teste porque os componentes de apresenta√ß√£o apenas "obteriam adere√ßos". Tamb√©m levou a muitas perfura√ß√µes de suporte, clich√™, padr√µes dif√≠ceis de digitar estaticamente (üëã componentes de ordem superior) e divis√µes arbitr√°rias de componentes.

Isso mudou muito quando os ganchos apareceram. Agora voc√™ pode useContext , useQuery ou useSelector (se estiver usando redux) em qualquer lugar e, assim, injetar depend√™ncias em seu componente. Voc√™ pode argumentar que isso torna seu componente mais acoplado. Voc√™ tamb√©m pode dizer que agora √© mais independente porque voc√™ pode mov√™-lo livremente em seu aplicativo e ele funcionar√° sozinho.

Eu recomendo totalmente assistir Hooks, HOCS, and Tradeoffs (‚ö°Ô∏è) / React Boston 2019 pelo mantenedor do redux Mark Erikson .

Em resumo, tudo s√£o compensa√ß√µes. Nao tem almo√ßo gratis. O que pode funcionar em uma situa√ß√£o pode n√£o funcionar em outras. Um componente Button reutiliz√°vel deve fazer a busca de dados? Provavelmente n√£o. Faz sentido dividir seu Dashboard em um DashboardView e um DashboardContainer que transmite dados? Tamb√©m, provavelmente n√£o. Portanto, cabe a n√≥s conhecer as compensa√ß√µes e aplicar a ferramenta certa para o trabalho certo.

## Aprendizado

O React Query √© √≥timo para gerenciar o estado ass√≠ncrono globalmente em seu aplicativo, se voc√™ permitir. S√≥ desative os sinalizadores de rebusca se souber que isso faz sentido para o seu caso de uso e resista ao desejo de sincronizar os dados do servidor com um gerenciador de estado diferente. Normalmente, personalizar o staleTime √© tudo o que voc√™ precisa para obter um √≥timo ux e, ao mesmo tempo, controlar a frequ√™ncia com que as atualiza√ß√µes em segundo plano acontecem.

