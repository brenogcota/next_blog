---
title: Testando o React Query
publishedOn: Sex. 15 de jul. 2022
tags: [React, Tests, React Query]
author: TkDodo
---

Esse post faz parte do [TkDodo's blog](https://tkdodo.eu/blog/) e Ã© uma traduÃ§Ã£o para o PortuguÃªs.

Perguntas sobre o tÃ³pico de teste surgem com bastante frequÃªncia junto com o React Query, entÃ£o tentarei responder algumas delas aqui. 
Acho que uma razÃ£o para isso Ã© que testar componentes "inteligentes" (tambÃ©m chamados de [componentes de contÃªiner](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) ) 
nÃ£o Ã© a coisa mais fÃ¡cil de fazer. Com o surgimento dos hooks, essa divisÃ£o foi amplamente preterida. Agora Ã© encorajado a consumir hooks 
diretamente onde vocÃª precisa deles, em vez de fazer uma divisÃ£o arbitrÃ¡ria e detalhar os adereÃ§os.

Eu acho que isso geralmente Ã© uma melhoria muito boa para colocation e legibilidade de cÃ³digo, mas agora temos mais componentes que consomem dependÃªncias 
fora de "apenas props".

Eles podem ser useContext. Eles podem ser useSelector. Ou eles podem ser useQuery.

Esses componentes tecnicamente nÃ£o sÃ£o mais puros, porque chamÃ¡-los em ambientes diferentes leva a resultados diferentes. Ao testÃ¡-los, vocÃª precisa 
configurar cuidadosamente os ambientes ao redor para que as coisas funcionem.

## Simulando solicitaÃ§Ãµes de rede

Como o React Query Ã© uma biblioteca de gerenciamento de estado de servidor assÃ­ncrono, seus componentes provavelmente farÃ£o solicitaÃ§Ãµes para um back-end. 
Ao testar, esse back-end nÃ£o estÃ¡ disponÃ­vel para entregar dados de fato e, mesmo assim, vocÃª provavelmente nÃ£o deseja tornar seus testes dependentes disso.

Existem muitos artigos por aÃ­ sobre como mock de dados com jest. VocÃª pode simular seu cliente de API, se tiver um. VocÃª pode simular busca ou axios 
diretamente. SÃ³ posso apoiar o que Kent C. Dodds escreveu em seu artigo [Stop mocking fetch](https://kentcdodds.com/blog/stop-mocking-fetch):

Use o service worker simulado por @ApiMocking

- funciona no nÃ³ para teste
- suporta REST e GraphQL
- tem um [story book addon](https://storybook.js.org/addons/msw-storybook-addon/) para que vocÃª possa escrever histÃ³rias para seus componentes que useQuery
- funciona no navegador para fins de desenvolvimento, e vocÃª ainda verÃ¡ as solicitaÃ§Ãµes saindo nas ferramentas de desenvolvimento do navegador
- trabalha com cypress, semelhante a fixtures

Com nossa camada de rede sendo cuidada, podemos comeÃ§ar a falar sobre coisas especÃ­ficas do React Query para ficar de olho:

## QueryClientProvider

Sempre que vocÃª usa React Query, vocÃª precisa de um QueryClientProvider e dÃ¡ a ele um queryClient - um recipiente que contÃ©m o QueryCache . O cache, 
por sua vez, manterÃ¡ os dados de suas consultas.

Eu prefiro dar a cada teste seu prÃ³prio QueryClientProvider e criar um novo QueryClient para cada teste. Dessa forma, os testes sÃ£o completamente isolados
uns dos outros. Uma abordagem diferente pode ser limpar o cache apÃ³s cada teste, mas gosto de manter o estado compartilhado entre os testes o mÃ­nimo 
possÃ­vel. Caso contrÃ¡rio, vocÃª poderÃ¡ obter resultados inesperados e irregulares se executar seus testes em paralelo.

## Para hooks personalizado

```Javascript
const createWrapper = () => {
  // âœ… creates a new QueryClient for each test
  const queryClient = new QueryClient()
  return ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

test("my first test", async () => {
  const { result } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })
}
```

## Para componentes

Se vocÃª quiser testar um Component que usa um gancho useQuery , vocÃª tambÃ©m precisa encapsular esse Component em QueryClientProvider. 
Um pequeno wrapper em torno da renderizaÃ§Ã£o da react-testing-library parece ser uma boa escolha. DÃª uma olhada em como o React Query faz isso 
internamente para seus testes.

## Desativar novas tentativas

Ã‰ uma das "pegadinhas" mais comuns com React Query e testes: a biblioteca tem como padrÃ£o trÃªs novas tentativas com backoff exponencial, o que significa
que seus testes provavelmente atingirÃ£o o tempo limite se vocÃª quiser testar uma consulta errÃ´nea. A maneira mais fÃ¡cil de desativar as novas tentativas
Ã©, novamente, por meio do QueryClientProvider . Vamos estender o exemplo acima:

```Javascript
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        // âœ… turns retries off
        retry: false,
      },
    },
  })

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

test("my first test", async () => {
  const { result } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })
}
```

Isso definirÃ¡ os padrÃµes para todas as consultas na Ã¡rvore de componentes como "sem novas tentativas". Ã‰ importante saber que isso sÃ³ funcionarÃ¡ se seu 
useQuery real nÃ£o tiver tentativas explÃ­citas definidas. Se vocÃª tiver uma consulta que deseja 5 tentativas, isso ainda terÃ¡ precedÃªncia, porque os 
padrÃµes sÃ£o usados â€‹â€‹apenas como um fallback.

## setQueryDefaults

O melhor conselho que posso dar para esse problema Ã©: NÃ£o defina essas opÃ§Ãµes em useQuery diretamente. Tente usar e substituir os padrÃµes o mÃ¡ximo possÃ­vel e, se vocÃª realmente precisar alterar algo para consultas especÃ­ficas, use queryClient.setQueryDefaults .

EntÃ£o, por exemplo, em vez de definir retry em useQuery:

```javascript
const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  // ğŸš¨ you cannot override this setting for tests!
  const queryInfo = useQuery('todos', fetchTodos, { retry: 5 })
}
```

Defina assim:

```javascript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
    },
  },
})

// âœ… only todos will retry 5 times
queryClient.setQueryDefaults('todos', { retry: 5 })

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
```

Aqui, todas as consultas vÃ£o tentar novamente duas vezes, apenas todos vÃ£o repetir cinco vezes, e ainda tenho a opÃ§Ã£o de desativÃ¡-lo para todas as 
consultas nos meus testes ğŸ™Œ.

## ReactQueryConfigProvider


```javascript
cÃ³pia deReactQueryConfigProvider: copie o cÃ³digo para a Ã¡rea de transferÃªncia
const ReactQueryConfigProvider = ({ children, defaultOptions }) => {
  const client = useQueryClient()
  const [newClient] = React.useState(
    () =>
      new QueryClient({
        queryCache: client.getQueryCache(),
        muationCache: client.getMutationCache(),
        defaultOptions,
      })
  )

  return (
    <QueryClientProvider client={newClient}>{children}</QueryClientProvider>
  )
}
```

VocÃª pode ver isso em aÃ§Ã£o neste [exemplo](https://codesandbox.io/s/react-query-config-provider-v3-lt00f) no codesandbox.

## Sempre aguarde a consulta

``` javascript
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  })
  return ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

test("my first test", async () => {
  const { result, waitFor } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })

  // âœ… wait until the query has transitioned to success state
  await waitFor(() => result.current.isSuccess)

  expect(result.current.data).toBeDefined()
}
```

AtualizaÃ§Ã£o :

@testing-library/react v13.1.0 tambÃ©m tem um novo renderHook que vocÃª pode usar. No entanto, ele nÃ£o retorna seu prÃ³prio waitFor util, 
entÃ£o vocÃª terÃ¡ que usar o que vocÃª pode importar de @testing-library/react. A API Ã© um pouco diferente, pois nÃ£o permite retornar um boolean, 
mas espera um Promise. Isso significa que devemos adaptar nosso cÃ³digo um pouco:

```javascript

Ir para o conteÃºdo
blog do TkDodo

Blog Tags Patrocinadores RSS
Twitter Github
Testando o React Query
04.04.2021â€” ReactJs , React Query , JavaScript , TypeScript â€” 4 min de leitura

testando
Foto de menina com chapÃ©u vermelho
Ãšltima atualizaÃ§Ã£o: 23.04.2022

NÂº 1: Consulta prÃ¡tica de reaÃ§Ã£o
NÂº 2: Reaja as transformaÃ§Ãµes de dados de consulta
NÂº 3: OtimizaÃ§Ãµes de renderizaÃ§Ã£o de consulta React
#4: VerificaÃ§Ãµes de status em React Query
NÂº 5: Testando React Query
#6: React Query e TypeScript
#7: Usando WebSockets com React Query
NÂº 8: Chaves de consulta React eficazes
#8a: Aproveitando o contexto da funÃ§Ã£o de consulta
#9: EspaÃ§o reservado e dados iniciais na consulta React
#10: Reaja a consulta como um gerenciador de estado
NÂº 11: Reagir como lidar com erros de consulta
#12: Dominando MutaÃ§Ãµes em React Query
NÂº 13: Consulta de reaÃ§Ã£o off-line
NÂº 14: Reagir a consulta e formulÃ¡rios
NÂº 15: Perguntas frequentes de consulta do React
coreano
Adicionar traduÃ§Ã£o
Perguntas sobre o tÃ³pico de teste surgem com bastante frequÃªncia junto com o React Query, entÃ£o tentarei responder algumas delas aqui. Acho que uma razÃ£o para isso Ã© que testar componentes "inteligentes" (tambÃ©m chamados de componentes de contÃªiner ) nÃ£o Ã© a coisa mais fÃ¡cil de fazer. Com o surgimento de ganchos, essa divisÃ£o foi amplamente preterida. Agora Ã© encorajado a consumir ganchos diretamente onde vocÃª precisa deles, em vez de fazer uma divisÃ£o arbitrÃ¡ria e detalhar os adereÃ§os.

Eu acho que isso geralmente Ã© uma melhoria muito boa para colocation e legibilidade de cÃ³digo, mas agora temos mais componentes que consomem dependÃªncias fora de "apenas props".

Eles podem usarContext . Eles podem usar Selector . Ou eles podem usarQuery .

Esses componentes tecnicamente nÃ£o sÃ£o mais puros, porque chamÃ¡-los em ambientes diferentes leva a resultados diferentes. Ao testÃ¡-los, vocÃª precisa configurar cuidadosamente os ambientes ao redor para que as coisas funcionem.

Simulando solicitaÃ§Ãµes de rede
Como o React Query Ã© uma biblioteca de gerenciamento de estado de servidor assÃ­ncrono, seus componentes provavelmente farÃ£o solicitaÃ§Ãµes para um back-end. Ao testar, esse back-end nÃ£o estÃ¡ disponÃ­vel para entregar dados de fato e, mesmo assim, vocÃª provavelmente nÃ£o deseja tornar seus testes dependentes disso.

Existem muitos artigos por aÃ­ sobre como zombar de dados com jest. VocÃª pode simular seu cliente de API, se tiver um. VocÃª pode simular busca ou axios diretamente. SÃ³ posso apoiar o que Kent C. Dodds escreveu em seu artigo Stop mocking fetch :

Use o service worker simulado por @ApiMocking

Pode ser sua Ãºnica fonte de verdade quando se trata de zombar de suas APIs:

funciona no nÃ³ para teste
suporta REST e GraphQL
tem um addon de livro de histÃ³rias para que vocÃª possa escrever histÃ³rias para seus componentes que usamQuery
funciona no navegador para fins de desenvolvimento, e vocÃª ainda verÃ¡ as solicitaÃ§Ãµes saindo nas ferramentas de desenvolvimento do navegador
trabalha com cipreste, semelhante a luminÃ¡rias
Com nossa camada de rede sendo cuidada, podemos comeÃ§ar a falar sobre coisas especÃ­ficas do React Query para ficar de olho:

QueryClientProvider
Sempre que vocÃª usa React Query, vocÃª precisa de um QueryClientProvider e dÃ¡ a ele um queryClient - um recipiente que contÃ©m o QueryCache . O cache, por sua vez, manterÃ¡ os dados de suas consultas.

Eu prefiro dar a cada teste seu prÃ³prio QueryClientProvider e criar um novo QueryClient para cada teste. Dessa forma, os testes sÃ£o completamente isolados uns dos outros. Uma abordagem diferente pode ser limpar o cache apÃ³s cada teste, mas gosto de manter o estado compartilhado entre os testes o mÃ­nimo possÃ­vel. Caso contrÃ¡rio, vocÃª poderÃ¡ obter resultados inesperados e irregulares se executar seus testes em paralelo.

Para ganchos personalizados
Se vocÃª estiver testando ganchos personalizados, tenho certeza de que estÃ¡ usando react-hooks-testing-library . Ã‰ a coisa mais fÃ¡cil que existe para testar ganchos. Com essa biblioteca, podemos envolver nosso gancho em um wrapper , que Ã© um componente React para envolver o componente de teste durante a renderizaÃ§Ã£o. Acho que este Ã© o lugar perfeito para criar o QueryClient, pois ele serÃ¡ executado uma vez por teste:

embrulho
cÃ³pia dewrapper: copie o cÃ³digo para a Ã¡rea de transferÃªncia
const createWrapper = () => {
  // âœ… creates a new QueryClient for each test
  const queryClient = new QueryClient()
  return ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

test("my first test", async () => {
  const { result } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })
}
Para componentes
Se vocÃª quiser testar um Component que usa um gancho useQuery , vocÃª tambÃ©m precisa encapsular esse Component em QueryClientProvider. Um pequeno wrapper em torno da renderizaÃ§Ã£o da react-testing-library parece ser uma boa escolha. DÃª uma olhada em como o React Query faz isso internamente para seus testes .

Desativar novas tentativas
Ã‰ uma das "pegadinhas" mais comuns com React Query e testes: a biblioteca tem como padrÃ£o trÃªs novas tentativas com backoff exponencial, o que significa que seus testes provavelmente atingirÃ£o o tempo limite se vocÃª quiser testar uma consulta errÃ´nea. A maneira mais fÃ¡cil de desativar as novas tentativas Ã©, novamente, por meio do QueryClientProvider . Vamos estender o exemplo acima:

sem tentativas
cÃ³pia desem tentativas: copie o cÃ³digo para a Ã¡rea de transferÃªncia
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        // âœ… turns retries off
        retry: false,
      },
    },
  })

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

test("my first test", async () => {
  const { result } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })
}
Isso definirÃ¡ os padrÃµes para todas as consultas na Ã¡rvore de componentes como "sem novas tentativas". Ã‰ importante saber que isso sÃ³ funcionarÃ¡ se seu useQuery real nÃ£o tiver tentativas explÃ­citas definidas. Se vocÃª tiver uma consulta que deseja 5 tentativas, isso ainda terÃ¡ precedÃªncia, porque os padrÃµes sÃ£o usados â€‹â€‹apenas como um fallback.

setQueryDefaults
O melhor conselho que posso dar para esse problema Ã©: NÃ£o defina essas opÃ§Ãµes em useQuery diretamente. Tente usar e substituir os padrÃµes o mÃ¡ximo possÃ­vel e, se vocÃª realmente precisar alterar algo para consultas especÃ­ficas, use queryClient.setQueryDefaults .

EntÃ£o, por exemplo, em vez de definir retry em useQuery :

consulta nÃ£o usada
cÃ³pia denot-on-useQuery: copie o cÃ³digo para a Ã¡rea de transferÃªncia
const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  // ğŸš¨ you cannot override this setting for tests!
  const queryInfo = useQuery('todos', fetchTodos, { retry: 5 })
}
Defina assim:

setQueryDefaults
cÃ³pia desetQueryDefaults: copie o cÃ³digo para a Ã¡rea de transferÃªncia
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
    },
  },
})

// âœ… only todos will retry 5 times
queryClient.setQueryDefaults('todos', { retry: 5 })

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}
Aqui, todas as consultas vÃ£o tentar novamente duas vezes, apenas todos vÃ£o repetir cinco vezes, e ainda tenho a opÃ§Ã£o de desativÃ¡-lo para todas as consultas nos meus testes ğŸ™Œ.

ReactQueryConfigProvider
Claro, isso sÃ³ funciona para chaves de consulta conhecidas. Ã€s vezes, vocÃª realmente deseja definir algumas configuraÃ§Ãµes em um subconjunto de sua Ã¡rvore de componentes. Na v2, o React Query tinha um ReactQueryConfigProvider para esse caso de uso exato. VocÃª pode conseguir a mesma coisa na v3 com algumas linhas de cÃ³digos:

ReactQueryConfigProvider
cÃ³pia deReactQueryConfigProvider: copie o cÃ³digo para a Ã¡rea de transferÃªncia
const ReactQueryConfigProvider = ({ children, defaultOptions }) => {
  const client = useQueryClient()
  const [newClient] = React.useState(
    () =>
      new QueryClient({
        queryCache: client.getQueryCache(),
        muationCache: client.getMutationCache(),
        defaultOptions,
      })
  )

  return (
    <QueryClientProvider client={newClient}>{children}</QueryClientProvider>
  )
}
VocÃª pode ver isso em aÃ§Ã£o neste exemplo de cÃ³digo e caixa .

Sempre aguarde a consulta
Como o React Query Ã© assÃ­ncrono por natureza, ao executar o gancho, vocÃª nÃ£o obterÃ¡ um resultado imediatamente. Geralmente estarÃ¡ em estado de carregamento e sem dados para verificar. Os utilitÃ¡rios assÃ­ncronos da react-hooks-testing-library oferecem muitas maneiras de resolver esse problema. Para o caso mais simples, podemos apenas esperar atÃ© que a consulta tenha feito a transiÃ§Ã£o para o estado de sucesso:

Esperar por
cÃ³pia dewaitFor: copia o cÃ³digo para a Ã¡rea de transferÃªncia
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  })
  return ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

test("my first test", async () => {
  const { result, waitFor } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })

  // âœ… wait until the query has transitioned to success state
  await waitFor(() => result.current.isSuccess)

  expect(result.current.data).toBeDefined()
}
AtualizaÃ§Ã£o :

@testing-library/react v13.1.0 tambÃ©m tem um novo renderHook que vocÃª pode usar. No entanto, ele nÃ£o retorna seu prÃ³prio waitFor util, entÃ£o vocÃª terÃ¡ que usar o que vocÃª pode importar de @testing-library/react . A API Ã© um pouco diferente, pois nÃ£o permite retornar um boolean , mas espera um Promise . Isso significa que devemos adaptar nosso cÃ³digo um pouco:

novo-render-hook
cÃ³pia denew-render-hook: copie o cÃ³digo para a Ã¡rea de transferÃªncia
import { waitFor, renderHook } from '@testing-library/react'

test("my first test", async () => {
  const { result } = renderHook(() => useCustomHook(), {
    wrapper: createWrapper()
  })

  // âœ… return a Promise via expect to waitFor
  await waitFor(() => expect(result.current.isSuccess).toBe(true))

  expect(result.current.data).toBeDefined()
}
```

## Silenciar o console de erro

Por padrÃ£o, o React Query imprime erros no console. Eu acho que isso Ã© bastante perturbador durante os testes, porque vocÃª verÃ¡ ğŸ”´ no console mesmo que 
todos os testes sejam ğŸŸ¢. O React Query permite sobrescrever esse comportamento padrÃ£o [definindo um logger](https://react-query.tanstack.com/reference/setLogger), 
entÃ£o Ã© isso que costumo fazer:

```javascript
import { setLogger } from 'react-query'

setLogger({
  log: console.log,
  warn: console.warn,
  // âœ… no more errors on the console
  error: () => {},
})
```

Atualizar

setLogger foi removido na v4. Em vez disso, vocÃª pode passar seu logger personalizado como prop para o QueryClient que vocÃª cria:

```javascript
cÃ³pia delogger-prop: copie o cÃ³digo para a Ã¡rea de transferÃªncia
const queryClient = new QueryClient({
  logger: {
    log: console.log,
    warn: console.warn,
    // âœ… no more errors on the console
    error: () => {},
  }
})
```

AlÃ©m disso, os erros nÃ£o sÃ£o mais registrados no modo de produÃ§Ã£o para evitar confusÃ£o.

## Juntando tudo

Eu configurei um repositÃ³rio rÃ¡pido onde tudo isso vem bem junto: mock-service-worker, react-testing-library e o wrapper mencionado. 
Ele contÃ©m quatro testes - testes bÃ¡sicos de falha e sucesso para ganchos e componentes personalizados. DÃª uma olhada 
aqui: https://github.com/TkDodo/testing-react-query



